## Overview

| Developed by | Guardrails AI |
| --- | --- |
| Date of development | Feb 15, 2024 |
| Validator type | Quality |
| Blog | - |
| License | Apache 2 |
| Input/Output | Output |

## Description

This validator checks that a value is similar to a list of previously known correct values.

For example, let’s say you’re extracting structured data from a PDF document, and extract some value. If you have an existing golden dataset of previous values, then this validator will ensure that the extracted value is not too different from known good values.

This validator works on numerical and string types in the following manner:

1. For numbers, this validator checks that the extracted value is within k standard deviations of the validator.
2. For strings, this validator embeds the extracted value, generates embeddings for all reference values, and checks that the average semantic similarity is more than some threshold.

## Installation

```bash
$ guardrails hub install hub://guardrails/similar_to_previous_values
```

## Usage Examples

### Validating string output via Python

In this example, we apply the validator to a string output generated by an LLM.

```python
# Import Guard and Validator
from guardrails.hub import SimilarToPreviousValues
from guardrails import Guard

# Initialize Validator
val = SimilarToPreviousValues(
		standard_deviations=2,
		on_fail="fix"
)

# Setup Guard
guard = Guard.from_string(
    validators=[val, ...],
)

prev_vals = [1, 2, 3, 4]

guard.parse(2.5, metadata={'prev_values': prev_vals})  # Validator passes
guard.parse(50, metadata={'prev_values': prev_vals})  # Validator fails
```

### Validating JSON output via Python

In this example, we apply the validator on the string field of a JSON output.

```python
# Import Guard and Validator
from pydantic import BaseModel
from guardrails.hub import SimilarToPreviousValues
from guardrails import Guard

val = SimilarToPreviousValues(threshold=0.5, on_fail="fix")

# Create Pydantic BaseModel
class ExtractedData(BaseModel):
		name: str
		description: str = Field(
				description="Some description", validators=[val]
		)

# Create a Guard to check for valid Pydantic output
guard = Guard.from_pydantic(output_class=ExtractedData)

# Create golden dataset
prev_vals = [
		"description 1",
		"description 2",
		"description 3"
]

# Run LLM output generating JSON through guard
guard.parse("""
{
		"name": "Caesar",
		"description": "description 4"
}
""")
```


## API Reference

`__init__`

- `standard_deviations`: Max number of standard deviations that the extracted value should be within. Required for numbers.
- `threshold`: Average similarity threshold below which the validator will fail. Required for strings.
- `on_fail`: The policy to enact when a validator fails.

`parse` :

- `metadata` :
    - `prev_vals` : List of previous values to pass to the validator
